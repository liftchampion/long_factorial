# Long Factorial!

## О проекте:
**Задача**: Необходимо посчитать и вывести на экран большой факториал (например 2000!).  
**Решение**: Длинная арифметика для задачи была реализована двумя способами:  
+ с помощью std::bitset  
+ с помощью std::deque  


## Bitset
Длинная арифметика через bitset реализована следубщим образом. 
Создан bitset на 20032 бита (этого количества достаточно, чтобы вместить 2000!). Арифметические операции были реализованы через битовые.

## Deque
Длинная арифметика через deque реализована следующим образом.  
Создан deque, из 64-битных интов. Deque использовался по причине того, что одновременно был нужен и push_back и push_front.
Число в каждой ячейке дека ограничено 10^18. Это число должно быть степенью десятки для удобного вывода. Должно быть большим, чтобы минимизировать количество операций, и должно быть достаточно маленьким, чтобы сумма двух ячеек не переполняла uint64.  
Далее все арифметические операции выполнялись в системе исчисления с основанием 10^18.  

## Deque vs Bitset
Решение с помощью deque показало себя гораздо лучше по ряду причин.

У реализации через bitset есть только один очевидный плюс. Это возможность выполнять умножение как сумму битовых сдвигов.  
Также у неё есть огромный минус: так как нам требуется вывести полученный факториал на экран, то приходится выполнять перевод из двочиной системы в десятичную. Так как, по очевидным причинам, воспользоваться классическим алгоритмом через умножение мы не можем, я решил производить перевод производя последовательное деление на степень десятки. Полученные остатки от деления сохранялись в вектор, а затем печатались в обратном порядке.  
Деление занимало 99% времени работы программы.  


